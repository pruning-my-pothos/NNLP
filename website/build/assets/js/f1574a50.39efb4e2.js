"use strict";(self.webpackChunkgenai_llm_documentation_website=self.webpackChunkgenai_llm_documentation_website||[]).push([[2646],{22333(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"foundations/04-sequential-models/types-of-rnn-cardinality","title":"Types of RNNs Based on Cardinality","description":"Explore the different architectures of Recurrent Neural Networks (RNNs) categorized by the relationship between their input and output sequence lengths (cardinality), and understand their applications in various sequential tasks.","source":"@site/../docs/foundations/04-sequential-models/types-of-rnn-cardinality.md","sourceDirName":"foundations/04-sequential-models","slug":"/foundations/04-sequential-models/types-of-rnn-cardinality","permalink":"/gen-ai-llm-docs/docs/foundations/04-sequential-models/types-of-rnn-cardinality","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":2,"frontMatter":{"title":"Types of RNNs Based on Cardinality","description":"Explore the different architectures of Recurrent Neural Networks (RNNs) categorized by the relationship between their input and output sequence lengths (cardinality), and understand their applications in various sequential tasks.","sidebar_position":2},"sidebar":"mainSidebar","previous":{"title":"Introduction to Sequential Data and RNNs","permalink":"/gen-ai-llm-docs/docs/foundations/04-sequential-models/introduction-to-sequential-data-and-rnn"},"next":{"title":"Training RNNs: Backpropagation Through Time (BPTT)","permalink":"/gen-ai-llm-docs/docs/foundations/04-sequential-models/training-rnns-bptt"}}');var i=t(74848),r=t(28453);const a={title:"Types of RNNs Based on Cardinality",description:"Explore the different architectures of Recurrent Neural Networks (RNNs) categorized by the relationship between their input and output sequence lengths (cardinality), and understand their applications in various sequential tasks.",sidebar_position:2},o="Types of RNNs Based on Cardinality",l={},c=[{value:"1. One-to-One (Vanilla Neural Networks)",id:"1-one-to-one-vanilla-neural-networks",level:2},{value:"2. One-to-Many",id:"2-one-to-many",level:2},{value:"3. Many-to-One",id:"3-many-to-one",level:2},{value:"4. Many-to-Many (Synchronous / Same Length)",id:"4-many-to-many-synchronous--same-length",level:2},{value:"5. Many-to-Many (Asynchronous / Encoder-Decoder)",id:"5-many-to-many-asynchronous--encoder-decoder",level:2},{value:"Relevance to Generative AI and LLMs",id:"relevance-to-generative-ai-and-llms",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"types-of-rnns-based-on-cardinality",children:"Types of RNNs Based on Cardinality"})}),"\n",(0,i.jsx)(n.admonition,{title:"Different Blueprints for Different Problems",type:"info",children:(0,i.jsxs)(n.p,{children:["Think of the different RNN types not as fundamentally different models, but as different ",(0,i.jsx)(n.strong,{children:"blueprints"})," for using the same core RNN cell. The underlying mechanics of the cell (processing one item and passing on a hidden state) remain the same. What changes is how you wire it up to handle the specific input and output shapes your problem requires."]})}),"\n",(0,i.jsxs)(n.p,{children:["Recurrent Neural Networks (RNNs) are highly versatile and can be configured in various ways to handle different types of sequential data tasks. A common way to categorize RNN architectures is by the relationship between the number of inputs and the number of outputs in a sequence, often referred to as ",(0,i.jsx)(n.strong,{children:"cardinality"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Understanding these different types helps in selecting the right RNN architecture for a specific problem."}),"\n",(0,i.jsx)(n.h2,{id:"1-one-to-one-vanilla-neural-networks",children:"1. One-to-One (Vanilla Neural Networks)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Single input (e.g., a single image)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Single output (e.g., a single label)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": This is the simplest form, essentially a traditional feedforward neural network (like a Multi-Layer Perceptron) applied to a single data point. It doesn't truly leverage the recurrent nature for sequence processing, as there's no temporal dependency."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Application"}),": Image classification, standard classification tasks.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Suggestion"}),": A single node representing input, connected to a single node representing output."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    Input --\x3e Output"}),"\n",(0,i.jsx)(n.h2,{id:"2-one-to-many",children:"2. One-to-Many"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Single input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Sequence of outputs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": The RNN takes a single input and generates a sequence. The internal state of the RNN is maintained and updated as it generates each element of the output sequence."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Image Captioning"}),": Input an image, output a descriptive sentence."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Music Generation"}),": Input a genre/style, output a sequence of notes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actionable Insight"}),": The single input often acts as an initial context or seed from which the sequence is generated."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Analogy: The Artist's Prompt",type:"tip",children:[(0,i.jsx)(n.p,{children:"A great analogy for the one-to-many architecture is giving a single prompt to an artist."}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),': "A futuristic city at sunset."']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output Sequence"}),": The artist (the RNN) generates a sequence of brushstrokes, colors, and shapes to create the final painting.\nThe initial prompt sets the context for the entire generated sequence."]}),"\n"]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Suggestion"}),": A single input node feeding into an RNN cell, which then produces multiple output nodes sequentially."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    I(Input) --\x3e RNN\n    RNN --\x3e O1(Output 1)\n    RNN -- State --\x3e RNN\n    RNN --\x3e O2(Output 2)\n    RNN -- State --\x3e RNN\n    RNN --\x3e O3(Output 3)"}),"\n",(0,i.jsx)(n.h2,{id:"3-many-to-one",children:"3. Many-to-One"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Sequence of inputs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Single output."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": The RNN processes an entire input sequence and then produces a single output that summarizes or classifies the sequence. The final hidden state of the RNN often contains the aggregated information from the entire sequence."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sentiment Analysis"}),": Input a sentence (sequence of words), output its sentiment (positive/negative)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spam Detection"}),": Input an email (sequence of words), output whether it's spam or not."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Video Classification"}),": Input a sequence of video frames, output the action performed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actionable Insight"}),": This architecture is excellent for tasks where the overall meaning or categorization of a sequence is required."]}),"\n",(0,i.jsx)(n.admonition,{title:"Analogy: The Funnel",type:"tip",children:(0,i.jsxs)(n.p,{children:["This architecture acts like a ",(0,i.jsx)(n.strong,{children:"funnel"}),'. It takes in a lot of information (a sequence of words, a series of video frames) and distills it all down into a single, conclusive output, such as "positive sentiment" or "this is a cat video." The final output is a summary judgment of the entire sequence.']})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Suggestion"}),": Multiple input nodes feeding sequentially into an RNN cell, with a single output node at the very end."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    I1(Input 1) --\x3e RNN1\n    RNN1 -- State --\x3e RNN2\n    I2(Input 2) --\x3e RNN2\n    RNN2 -- State --\x3e RNN3\n    I3(Input 3) --\x3e RNN3\n    RNN3 --\x3e O(Output)"}),"\n",(0,i.jsx)(n.h2,{id:"4-many-to-many-synchronous--same-length",children:"4. Many-to-Many (Synchronous / Same Length)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Sequence of inputs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Sequence of outputs, where each input corresponds to one output. The input and output sequences have the same length."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": The RNN produces an output at each time step, synchronized with the input sequence. The hidden state is passed along, maintaining context."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Application"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Part-of-Speech (POS) Tagging"}),": Input a sentence (sequence of words), output the POS tag for each word."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Named Entity Recognition (NER)"}),": Input a sentence, output the entity label for each word."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actionable Insight"}),": Ideal for tasks where a label or classification is needed for each element within an input sequence.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Suggestion"}),": Multiple input nodes feeding sequentially into an RNN cell, with each RNN cell also producing an output."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    I1(Input 1) --\x3e RNN1\n    RNN1 --\x3e O1(Output 1)\n    RNN1 -- State --\x3e RNN2\n    I2(Input 2) --\x3e RNN2\n    RNN2 --\x3e O2(Output 2)\n    RNN2 -- State --\x3e RNN3\n    I3(Input 3) --\x3e RNN3\n    RNN3 --\x3e O3(Output 3)"}),"\n",(0,i.jsx)(n.h2,{id:"5-many-to-many-asynchronous--encoder-decoder",children:"5. Many-to-Many (Asynchronous / Encoder-Decoder)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Sequence of inputs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Sequence of outputs, where the input and output sequences can have different lengths."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": This is a more complex architecture typically composed of two main parts:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Encoder"}),": Processes the entire input sequence, compressing its information into a fixed-size context vector (the final hidden state)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoder"}),": Takes the context vector from the encoder and generates the output sequence one element at a time."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Machine Translation"}),": Input a sentence in language A, output a sentence in language B (different lengths are common)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Text Summarization"}),": Input a long document, output a shorter summary."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Question Answering"}),": Input a question and context, output an answer."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actionable Insight"}),": This architecture is foundational for sequence-to-sequence tasks and is a direct precursor to the Transformer architecture used in LLMs."]}),"\n",(0,i.jsx)(n.admonition,{title:"A Foundational Leap Towards Transformers",type:"info",children:(0,i.jsxs)(n.p,{children:["Pay special attention to this architecture. The ",(0,i.jsx)(n.strong,{children:"Encoder-Decoder"}),' model is arguably the most important conceptual stepping stone on the path to modern LLMs. The idea of compressing an entire input sequence into a "context vector" and then having a separate decoder generate an output from it was a revolutionary idea. The Transformer architecture, which powers models like GPT, is a more advanced and powerful implementation of this same fundamental Encoder-Decoder concept.']})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual Suggestion"}),': A sequence of inputs feeding into an "Encoder" block, which outputs a single context vector. This context vector then feeds into a "Decoder" block, which outputs a sequence.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    subgraph Encoder\n        I1(Input 1) --\x3e E1(Enc Cell)\n        E1 -- State --\x3e E2(Enc Cell)\n        I2(Input 2) --\x3e E2\n        E2 -- State --\x3e E3(Enc Cell)\n        I3(Input 3) --\x3e E3\n    end\n    E3 -- Context Vector --\x3e D1(Dec Cell)\n    subgraph Decoder\n        D1 --\x3e O1(Output 1)\n        D1 -- State --\x3e D2(Dec Cell)\n        D2 --\x3e O2(Output 2)\n        D2 -- State --\x3e D3(Dec Cell)\n        D3 --\x3e O3(Output 3)\n    end"}),"\n",(0,i.jsx)(n.h2,{id:"relevance-to-generative-ai-and-llms",children:"Relevance to Generative AI and LLMs"}),"\n",(0,i.jsx)(n.p,{children:"The Many-to-Many (Encoder-Decoder) architecture became critically important for tasks like machine translation, which eventually paved the way for the Transformer architecture. LLMs, at their core, can be seen as highly sophisticated generative sequence models, often leveraging a decoder-only architecture for text generation, built upon the principles refined in these various RNN types."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["Next, we'll delve into the training process for RNNs, specifically ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/gen-ai-llm-docs/docs/foundations/04-sequential-models/training-rnns-bptt",children:"Training RNNs: Backpropagation Through Time (BPTT)"})}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);