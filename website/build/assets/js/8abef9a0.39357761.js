"use strict";(self.webpackChunkgenai_llm_documentation_website=self.webpackChunkgenai_llm_documentation_website||[]).push([[8573],{28453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},99433(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"01-handbook-core-method/execution-patterns/09-rubber-duck","title":"Pattern: The Rubber Duck","description":"Use this pattern to debug complex logic or understand legacy code. It forces the AI to explain the code\'s behavior step-by-step, often revealing the bug before you even ask for a fix.","source":"@site/../docs/01-handbook-core-method/execution-patterns/09-rubber-duck.md","sourceDirName":"01-handbook-core-method/execution-patterns","slug":"/01-handbook-core-method/execution-patterns/09-rubber-duck","permalink":"/gen-ai-llm-docs/docs/01-handbook-core-method/execution-patterns/09-rubber-duck","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"pattern","permalink":"/gen-ai-llm-docs/docs/tags/pattern"},{"inline":true,"label":"debugging","permalink":"/gen-ai-llm-docs/docs/tags/debugging"},{"inline":true,"label":"analysis","permalink":"/gen-ai-llm-docs/docs/tags/analysis"},{"inline":true,"label":"explanation","permalink":"/gen-ai-llm-docs/docs/tags/explanation"}],"version":"current","lastUpdatedAt":null,"frontMatter":{"title":"Pattern: The Rubber Duck","archetype":"pattern","status":"active","owner":"Shailesh (Shaily)","maintainer":"Shailesh (Shaily)","version":"0.1.0","tags":["pattern","debugging","analysis","explanation"],"last_reviewed":"2025-12-28"}}');var s=t(74848),i=t(28453);const o={title:"Pattern: The Rubber Duck",archetype:"pattern",status:"active",owner:"Shailesh (Shaily)",maintainer:"Shailesh (Shaily)",version:"0.1.0",tags:["pattern","debugging","analysis","explanation"],last_reviewed:"2025-12-28"},a="Pattern: The Rubber Duck",l={},c=[{value:"Overview",id:"overview",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"The Pattern (Step-by-Step)",id:"the-pattern-step-by-step",level:2},{value:"Step 1: The Context Dump",id:"step-1-the-context-dump",level:3},{value:"Step 2: The Walkthrough",id:"step-2-the-walkthrough",level:3},{value:"Step 3: The Interrogation",id:"step-3-the-interrogation",level:3},{value:"Step 4: The Fix",id:"step-4-the-fix",level:3},{value:"Example Scenario",id:"example-scenario",level:2},{value:"Practical Example: Debugging a Stale Closure in React",id:"practical-example-debugging-a-stale-closure-in-react",level:3}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pattern-the-rubber-duck",children:"Pattern: The Rubber Duck"})}),"\n",(0,s.jsx)(n.admonition,{title:"Value Proposition",type:"info",children:(0,s.jsx)(n.p,{children:"Use this pattern to debug complex logic or understand legacy code. It forces the AI to explain the code's behavior step-by-step, often revealing the bug before you even ask for a fix."})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:['"Rubber Ducking" is a classic debugging technique where you explain your code line-by-line to an inanimate object. Here, the AI acts as an ',(0,s.jsx)(n.strong,{children:"active"})," rubber duck."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Isolate the root cause of a bug or understand a complex flow.\n",(0,s.jsx)(n.strong,{children:"Anti-pattern"}),': "Fix this error." (Result: AI guesses blindly without understanding the state).']}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"\u2705 Use This Pattern When..."}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"\ud83d\udeab Do Not Use When..."})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You have a stack trace but no idea why"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You need to write a new feature"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You are reading code you didn't write"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You are doing a large-scale refactor"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You suspect a race condition or edge case"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"You know exactly what the fix is"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.admonition,{title:"Before you start",type:"warning",children:(0,s.jsx)(n.p,{children:"Do not paste the error log alone. You must provide the code that caused it."})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Source code + Error logs / Observed behavior."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context"}),": What were you trying to do when it failed?"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"the-pattern-step-by-step",children:"The Pattern (Step-by-Step)"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-the-context-dump",children:"Step 1: The Context Dump"}),"\n",(0,s.jsx)(n.p,{children:"Feed the code and the error to the model."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['"Here is ',(0,s.jsx)(n.code,{children:"src/payment.ts"}),' and the error log from the last run. Do not fix it yet."']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-2-the-walkthrough",children:"Step 2: The Walkthrough"}),"\n",(0,s.jsx)(n.p,{children:"Ask the AI to trace the execution path for the specific scenario that failed."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['"Trace the execution flow for a user with an expired card. Explain the state of the ',(0,s.jsx)(n.code,{children:"transaction"}),' object at each step."']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Why? This forces the model to build an internal representation of the logic flow."})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-the-interrogation",children:"Step 3: The Interrogation"}),"\n",(0,s.jsx)(n.p,{children:'Ask specific "What if" questions to test hypotheses.'}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['"What happens if the API returns a 503 at line 42? Is the ',(0,s.jsx)(n.code,{children:"catch"}),' block reachable?"']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-4-the-fix",children:"Step 4: The Fix"}),"\n",(0,s.jsx)(n.p,{children:"Once the logic gap is exposed, ask for the correction."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\"The error is that we don't check for ",(0,s.jsx)(n.code,{children:"null"})," before accessing ",(0,s.jsx)(n.code,{children:"transaction.id"}),'. Generate the fix."']}),"\n"]}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    Code[Code + Error] --\x3e Trace[Trace Execution]\n    Trace --\x3e Hypoth[Hypothesis]\n    Hypoth --\x3e Fix[Generate Fix]\n\n    classDef step fill:#E6F7FF,stroke:#1B75BB,color:#0F1F2E;\n    class Code,Trace,Hypoth,Fix step;"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-scenario",children:"Example Scenario"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context"}),": A React component crashes only on the second render."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Component code + ",(0,s.jsx)(n.code,{children:"useEffect"})," logic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Process"}),': Asked AI to "Trace the dependency array changes between render 1 and 2."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Outcome"}),": AI identified a stale closure in the event listener."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"practical-example-debugging-a-stale-closure-in-react",children:"Practical Example: Debugging a Stale Closure in React"}),"\n",(0,s.jsxs)(n.p,{children:["Consider a React component that displays a counter and updates it every second, but has a bug where the ",(0,s.jsx)(n.code,{children:"onClick"})," handler always logs the initial count."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Problematic Code (",(0,s.jsx)(n.code,{children:"Counter.jsx"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(count + 1); // Bug: 'count' is always 0 here due to stale closure\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Empty dependency array means 'count' is captured once\n\n  const handleClick = () => {\n    console.log('Button clicked, count:', count); // Stale closure: logs initial count\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Log Count</button>\n    </div>\n  );\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Step 1: The Context Dump"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"User Prompt:"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\"I'm getting the following error in my React application. The page renders a ",(0,s.jsx)(n.code,{children:"UserProfile"})," component."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error Message:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"TypeError: Cannot read property 'name' of undefined\n    at UserProfile (UserProfile.jsx:15:27)\n    at renderWithHooks (react-dom.development.js:16301:18)\n    at mountIndeterminateComponent (react-dom.development.js:19240:13)\n    ...\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Relevant Code (UserProfile.jsx line 15-18):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// UserProfile.jsx\n// ...\nfunction UserProfile({ user }) {\n    // ...\n    return (\n        <div>\n            <h1>Welcome, {user.name}!</h1> {/* Line 15 */}\n            <p>Email: {user.email}</p>\n        </div>\n    );\n}\n// ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question"}),": What is the most likely cause of this error, and what's a simple diagnostic step I can take?\""]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n**AI Response (Example):**\n```markdown\n**Most Likely Cause:**\nThe `TypeError: Cannot read property 'name' of undefined` at `UserProfile.jsx:15` strongly suggests that the `user` prop passed to the `UserProfile` component is `undefined` when the component tries to access `user.name`. This often happens when data is being fetched asynchronously, and the component renders before the data is available.\n\n**Simple Diagnostic Step:**\nAdd a `console.log` statement to inspect the `user` prop directly at the beginning of the `UserProfile` component.\n\n```javascript\n// UserProfile.jsx\nfunction UserProfile({ user }) {\n    console.log(\"User prop:\", user); // Add this line\n    // ...\n    return (\n        <div>\n            <h1>Welcome, {user.name}!</h1>\n            <p>Email: {user.email}</p>\n        </div>\n    );\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'*(Developer runs the app, observes `console.log("User prop:", undefined)`.)*\n\n2.  **Proposed Fix (Prompt to AI):**\n```markdown\n"The `console.log` confirmed that the `user` prop is `undefined` when `UserProfile` first renders. How can I fix `UserProfile.jsx` to prevent this error and show a loading state or a message if `user` is not yet available?"\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"AI Response (Example):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"**Proposed Fix:**\nYou can add a conditional rendering check for the `user` prop. If `user` is `undefined` or `null`, you can render a loading indicator or a message.\n\n```javascript\n// UserProfile.jsx\nimport React from 'react'; // Ensure React is imported if JSX is used\n\nfunction UserProfile({ user }) {\n    console.log(\"User prop:\", user);\n\n    if (!user) {\n        return <div>Loading user profile...</div>; // Or render a spinner\n    }\n\n    return (\n        <div>\n            <h1>Welcome, {user.name}!</h1>\n            <p>Email: {user.email}</p>\n        </div>\n    );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rationale:"}),"\nThis fix addresses the ",(0,s.jsx)(n.code,{children:"TypeError"})," by ensuring that ",(0,s.jsx)(n.code,{children:"user.name"})," is only accessed when ",(0,s.jsx)(n.code,{children:"user"})," is a defined object. It gracefully handles the asynchronous nature of data loading, providing a better user experience by showing a loading state instead of crashing."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Potential Side Effects:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If the ",(0,s.jsx)(n.code,{children:"user"}),' data never resolves, the "Loading" message will persist indefinitely. Consider adding a timeout or error handling for the data fetching mechanism upstream.']}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"user"})," could potentially be an empty object ",(0,s.jsx)(n.code,{children:"{}"})," but still ",(0,s.jsx)(n.code,{children:"truthy"}),", you might need more specific checks (e.g., ",(0,s.jsx)(n.code,{children:"if (!user || !user.name)"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n---\n\n## Common Pitfalls\n\n| Pitfall                   | Impact                                   | Correction                                     |\n| :------------------------ | :--------------------------------------- | :--------------------------------------------- |\n| **Premature Fixing**      | AI provides generic, unhelpful debugging advice. | Always provide full stack traces, relevant code, and exact error messages. |\n| **Missing Context**       | AI assumes standard behavior.            | Explicitly state environment details, recent changes, and any known system quirks. |\n| **Skipping Validation**   | Implementing AI's suggested fix without verifying the root cause. | Always confirm the hypothesis with further diagnostics before applying a fix. |\n\n:::danger[Critical Risk]\nNever apply AI-suggested fixes directly to production without thorough testing and understanding. Debugging AI is a partnership: you provide the evidence, AI provides hypotheses, but *you* are responsible for validation.\n:::\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);