"use strict";(self.webpackChunkgenai_llm_documentation_website=self.webpackChunkgenai_llm_documentation_website||[]).push([[4970],{28453(e,t,n){n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const a={},l=r.createContext(a);function i(e){const t=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(l.Provider,{value:t},e.children)}},54029(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"01-handbook-core-method/execution-patterns/03-strangler-refactor","title":"Pattern: The Strangler","description":"Use this pattern to refactor legacy systems incrementally. It allows you to replace old code with new code piece by piece, reducing the risk of a \\"Big Bang\\" rewrite failure.","source":"@site/../docs/01-handbook-core-method/execution-patterns/03-strangler-refactor.md","sourceDirName":"01-handbook-core-method/execution-patterns","slug":"/01-handbook-core-method/execution-patterns/03-strangler-refactor","permalink":"/gen-ai-llm-docs/docs/01-handbook-core-method/execution-patterns/03-strangler-refactor","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"pattern","permalink":"/gen-ai-llm-docs/docs/tags/pattern"},{"inline":true,"label":"refactoring","permalink":"/gen-ai-llm-docs/docs/tags/refactoring"},{"inline":true,"label":"legacy","permalink":"/gen-ai-llm-docs/docs/tags/legacy"},{"inline":true,"label":"migration","permalink":"/gen-ai-llm-docs/docs/tags/migration"}],"version":"current","lastUpdatedAt":null,"frontMatter":{"title":"Pattern: The Strangler","archetype":"pattern","status":"active","owner":"Shailesh (Shaily)","maintainer":"Shailesh (Shaily)","version":"0.1.0","tags":["pattern","refactoring","legacy","migration"],"last_reviewed":"2025-12-28"}}');var a=n(74848),l=n(28453);const i={title:"Pattern: The Strangler",archetype:"pattern",status:"active",owner:"Shailesh (Shaily)",maintainer:"Shailesh (Shaily)",version:"0.1.0",tags:["pattern","refactoring","legacy","migration"],last_reviewed:"2025-12-28"},s="Pattern: The Strangler",c={},o=[{value:"Overview",id:"overview",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"The Pattern (Step-by-Step)",id:"the-pattern-step-by-step",level:2},{value:"Step 1: Characterization (The &quot;Black Box&quot;)",id:"step-1-characterization-the-black-box",level:3},{value:"Step 2: The Seam (The Interface)",id:"step-2-the-seam-the-interface",level:3},{value:"Step 3: The Shadow Implementation",id:"step-3-the-shadow-implementation",level:3},{value:"Step 4: The Switch",id:"step-4-the-switch",level:3},{value:"Example Scenario",id:"example-scenario",level:2},{value:"Practical Example: Migrating a Calculator",id:"practical-example-migrating-a-calculator",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Last Reviewed / Last Updated",id:"last-reviewed--last-updated",level:2}];function d(e){const t={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"pattern-the-strangler",children:"Pattern: The Strangler"})}),"\n",(0,a.jsx)(t.admonition,{title:"Value Proposition",type:"info",children:(0,a.jsx)(t.p,{children:'Use this pattern to refactor legacy systems incrementally. It allows you to replace old code with new code piece by piece, reducing the risk of a "Big Bang" rewrite failure.'})}),"\n",(0,a.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(t.p,{children:'The "Strangler Fig" pattern involves wrapping legacy code with a new interface, then gradually replacing the internals until the old system can be deleted.'}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Goal"}),": Replace legacy logic without breaking production.\n",(0,a.jsx)(t.strong,{children:"Anti-pattern"}),': "Rewrite this entire module." (Result: Months of work, massive regressions).']}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"\u2705 Use This Pattern When..."}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"\ud83d\udeab Do Not Use When..."})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You are migrating a monolith to microservices"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You are writing a new feature from scratch"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You are replacing a deprecated library"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You are fixing a simple bug"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You need to refactor a critical, high-risk path"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"You can afford downtime"})]})]})]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(t.admonition,{title:"Before you start",type:"warning",children:(0,a.jsx)(t.p,{children:"You must have a way to run both the old and new code paths simultaneously (e.g., feature flags or an abstraction layer)."})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Input"}),": Legacy source code."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Safety"}),": Existing tests or a way to capture production inputs/outputs."]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"the-pattern-step-by-step",children:"The Pattern (Step-by-Step)"}),"\n",(0,a.jsx)(t.h3,{id:"step-1-characterization-the-black-box",children:'Step 1: Characterization (The "Black Box")'}),"\n",(0,a.jsxs)(t.p,{children:["Before changing anything, ask the AI to write a test that captures the ",(0,a.jsx)(t.em,{children:"current"})," behavior (bugs and all)."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"Write a test for ',(0,a.jsx)(t.code,{children:"legacyCalc.js"}),' that covers the happy path and edge cases. Treat the code as the source of truth."']}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"step-2-the-seam-the-interface",children:"Step 2: The Seam (The Interface)"}),"\n",(0,a.jsx)(t.p,{children:"Ask the AI to extract an interface or facade around the legacy code."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"Refactor ',(0,a.jsx)(t.code,{children:"legacyCalc.js"})," to hide its logic behind a ",(0,a.jsx)(t.code,{children:"Calculator"}),' interface. Do not change the logic yet."']}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"step-3-the-shadow-implementation",children:"Step 3: The Shadow Implementation"}),"\n",(0,a.jsx)(t.p,{children:"Generate the new implementation alongside the old one."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"Create a new class ',(0,a.jsx)(t.code,{children:"ModernCalculator"})," that implements the ",(0,a.jsx)(t.code,{children:"Calculator"}),' interface using the Intent Spec. Do not delete the old class."']}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"step-4-the-switch",children:"Step 4: The Switch"}),"\n",(0,a.jsx)(t.p,{children:"Ask the AI to wire up a toggle."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"Update the factory to return ',(0,a.jsx)(t.code,{children:"ModernCalculator"})," if the feature flag ",(0,a.jsx)(t.code,{children:"USE_MODERN_CALC"})," is true, otherwise return ",(0,a.jsx)(t.code,{children:"LegacyCalculator"}),'."']}),"\n"]}),"\n",(0,a.jsx)(t.mermaid,{value:"flowchart LR\n    Call[Caller] --\x3e Switch{Feature Flag?}\n    Switch --\x3e|False| Old[Legacy Code]\n    Switch --\x3e|True| New[New Code]\n    Old & New --\x3e Result[Result]\n\n    classDef step fill:#E6F7FF,stroke:#1B75BB,color:#0F1F2E;\n    class Call,Switch,Old,New,Result step;"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"example-scenario",children:"Example Scenario"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Context"}),": Replacing a raw SQL query with an ORM."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Input"}),": The 50-line SQL string."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Process"}),": Created a Repository interface. Implemented ",(0,a.jsx)(t.code,{children:"SqlRepository"})," (old) and ",(0,a.jsx)(t.code,{children:"OrmRepository"})," (new)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Outcome"}),": Switched traffic gradually. Verified ORM queries matched SQL results."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"practical-example-migrating-a-calculator",children:"Practical Example: Migrating a Calculator"}),"\n",(0,a.jsxs)(t.p,{children:["Let's imagine a legacy system with a simple ",(0,a.jsx)(t.code,{children:"Calculator"})," function that needs to be refactored using the Strangler pattern."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Step 1: Characterization"}),"\n(Assume tests are written to cover the existing ",(0,a.jsx)(t.code,{children:"LegacyCalculator"})," behavior.)"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Step 2: The Seam (The Interface)"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"// calculator.interface.ts\ninterface Calculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Step 3: The Shadow Implementation"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"// legacy-calculator.ts\nclass LegacyCalculator implements Calculator {\n  add(a: number, b: number): number {\n    // This might have some legacy quirks, e.g., integer overflow issues\n    return a + b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n}\n\n// modern-calculator.ts\nclass ModernCalculator implements Calculator {\n  add(a: number, b: number): number {\n    // Modern, robust implementation\n    return a + b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Step 4: The Switch"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"// calculator-factory.ts\nimport { Calculator } from './calculator.interface';\nimport { LegacyCalculator } from './legacy-calculator';\nimport { ModernCalculator } from './modern-calculator';\n\n// This could come from a feature flag service, environment variable, etc.\nconst USE_MODERN_CALC = true; // or process.env.FEATURE_FLAG_MODERN_CALC === 'true';\n\nclass CalculatorFactory {\n  static getCalculator(): Calculator {\n    if (USE_MODERN_CALC) {\n      return new ModernCalculator();\n    }\n    return new LegacyCalculator();\n  }\n}\n\n// Usage in application code\nconst calculator = CalculatorFactory.getCalculator();\nconsole.log(calculator.add(5, 3)); // Will use ModernCalculator if flag is true\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Pitfall"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Impact"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Correction"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:(0,a.jsx)(t.strong,{children:"Changing Behavior"})}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:'"Fixing" bugs during the port.'}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Keep parity first. Fix bugs later."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:(0,a.jsx)(t.strong,{children:"Missing Seams"})}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Code is too coupled to wrap."}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:'Use the "Extract Method" pattern first.'})]})]})]}),"\n",(0,a.jsx)(t.admonition,{title:"Critical Risk",type:"danger",children:(0,a.jsx)(t.p,{children:"Do not delete the legacy code until the new code has run in production for a safe period (e.g., 1 week)."})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"last-reviewed--last-updated",children:"Last Reviewed / Last Updated"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Last reviewed: 2025-12-28"}),"\n",(0,a.jsx)(t.li,{children:"Version: 0.1.0"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);